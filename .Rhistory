# # Predykcja C&RT
# cart_preds_class_test <- predict(cart_model, newdata = df_test, type = "class")
# accuracy_cart_test <- mean(cart_preds_class_test == df_test$Occupancy)
#
# # Predykcja Random Forest
# rf_preds_class_test <- predict(rf_model, newdata = df_test, type = "class")
# accuracy_rf_test <- mean(rf_preds_class_test == df_test$Occupancy)
#
# cat(sprintf("\n➡️ Drzewo Decyzyjne (C&RT) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_cart_test))
# cat(sprintf("➡️ Las Losowy (Random Forest) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_rf_test))
# #_____________________________________________________________
# # Ocena Końcowa na Zbiorze Testowym (df_test) - TYLKO ACCURACY
# #_____________________________________________________________
# Predykcja dla 9 Obserwacji
df_test_no_target <- df_test %>% select(-Occupancy)
# Predykcja C&RT
pred_cart_9_prob <- predict(cart_model, newdata = df_test_no_target, type = "prob")[, "Zajete"]
class_cart_9 <- predict(cart_model, newdata = df_test_no_target, type = "class")
accuracy_cart_test <- mean(class_cart_9 == df_test$Occupancy)
# Predykcja Random Forest
pred_rf_9_prob <- predict(rf_model, newdata = df_test_no_target, type = "prob")[, "Zajete"]
class_rf_9 <- predict(rf_model, newdata = df_test_no_target, type = "class")
accuracy_rf_test <- mean(class_rf_9 == df_test$Occupancy)
cat(sprintf("\n➡️ Drzewo Decyzyjne (C&RT) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_cart_test))
cat(sprintf("➡️ Las Losowy (Random Forest) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_rf_test))
# Zestawienie wyników
results_9_obs <- data.frame(
Obserwacja = 1:9,
Prawdziwa_Klasa = df_test$Occupancy,
CART_Predykcja = class_cart_9,
CART_Prawdopodobienstwo = round(pred_cart_10_prob, 9),
RF_Predykcja = class_rf_9,
RF_Prawdopodobienstwo = round(pred_rf_10_prob, 9)
)
knitr::opts_chunk$set(echo = TRUE)
# instalacja pakietów
#install.packages(c("tidyverse", "caret", "randomForest", "pROC", "corrplot", "rpart.plot"))
# Wczytanie bibliotek
library(tidyverse)
library(lubridate)
library(caret)
library(corrplot)
library(randomForest)
library(rpart)
library(pROC)
library(rpart.plot)
# Wczytanie trzech zestawów danych
df1 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatraining.txt", header = TRUE, sep = ",")
df2 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatest.txt", header = TRUE, sep = ",")
df3 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatest2.txt", header = TRUE, sep = ",")
# Połączenie danych z wszystkich plików w jeden duży zbiór
# Podział na dane treningowe i testowe zostanie wykonany w dalszej części!
df <- bind_rows(df1, df2, df3)
# Wyświetlenie danych
head(df)
# Sprawdzenie wymiarów danych
dim(df)
# Sprawdzenie struktury danych
str(df)
# Sprawdzenie braków danych
sum(is.na(df))
sum(!complete.cases(df))
# Sprawdzenie podstawowych statystyk dla zmiennych
# Wykrywanie wartości błędnych, ekstremalnych i odstających
summary(df)
# Przekształcenie typów zmiennych, utworzenie nowych zmiennych
df <- df %>%
mutate(date = ymd_hms(date)) %>%  # Przekształcenie zmiennej 'date' na format daty
# Ujednolicenie i zaokrąglanie pomiarów (korygowanie sekundy 59 do następnej minuty)
mutate(date = if_else(second(date) == 59, ceiling_date(date, unit = "minute"), date)) %>%
mutate(
Hour = hour(date),
Minute = minute(date),
Time = paste0(str_pad(Hour, 2, pad = "0"), ":",
str_pad(Minute, 2, pad = "0")) %>% as.factor(), # Czas wykonania pomiaru godzina:minuta
DayOfWeek = wday(date, label = TRUE, abbr = TRUE) # Dzień Tygodnia
)
# Przekształcenie zmiennej docelowej i zmiennych Hour i Time na Factor (Klasyfikacja)
df <- df %>%
mutate(
Occupancy = factor(Occupancy, levels = c(0, 1), labels = c("Wolne", "Zajete")),
Hour = as.factor(Hour),
Time = as.factor(Time))
# Ostateczne selekcje kolumn
df <- df %>%
select(-date, -Minute, -Time)
# Struktura danych po Inżynierii Cech
str(df)
head(df)
# Sprawdzenie rozkładu klas w zmiennej docelowej - Occupancy
table(df$Occupancy)
prop.table(table(df$Occupancy))
# Wizualizacja rozkładu klas
hist_occupancy <- ggplot(df, aes(x = Occupancy, fill = Occupancy)) +
geom_bar() +
labs(title = "Rozkład zmiennej Occupancy", y = "Liczba Obserwacji") +
theme_minimal()
print(hist_occupancy)
# Analiza zmiennych numerycznych: Temperature, Humidity, Light, CO2, HumidityRatio
# Histogramy
hist_all <- df %>%
select(Temperature, Humidity, Light, CO2, HumidityRatio) %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = Value)) +
geom_histogram(bins = 30, fill = "#1F78B4", color = "white") +
facet_wrap(~ Variable, scales = "free") +
labs(title = "Histogramy Rozkładu Głównych Zmiennych Środowiskowych",
x = "Wartość", y = "Liczność") +
theme_minimal()
print(hist_all)
# Boxploty
boxplot_occupancy <- df %>%
select(Occupancy, Temperature, Humidity, Light, CO2, HumidityRatio) %>%
pivot_longer(cols = c(Temperature, Humidity, Light, CO2, HumidityRatio), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = Occupancy, y = Value, fill = Occupancy)) +
geom_boxplot(alpha = 0.8) +
facet_wrap(~ Variable, scales = "free_y", ncol = 4) +
labs(title = "Boxploty Zmiennych Środowiskowych w zależności od Zajętości",
x = "Status Zajętości", y = "Wartość Zmiennej") +
theme_minimal() +
theme(legend.position = "none")
print(boxplot_occupancy)
# Wykres Słupkowy - wizualizacja proporcji zajętości w zależności od dnia tygodnia
barplot_dayofweek <- ggplot(df, aes(x = DayOfWeek, fill = Occupancy)) +
geom_bar(position = "fill") +
labs(title = "Proporcja Zajętości w zależności od Dnia Tygodnia",
y = "Proporcja", x = "Dzień Tygodnia") +
scale_fill_manual(values = c("Wolne" = "#A6CEE3", "Zajete" = "#FF7F00")) +
theme_minimal()
print(barplot_dayofweek)
# Zależność od Godziny
viz_hour <- ggplot(df, aes(x = Hour, fill = Occupancy)) +
geom_bar(position = "fill") +
labs(title = "Proporcja zajętości w zależności od Godziny",
y = "Proporcja", x = "Godzina (0-23)") +
scale_fill_manual(values = c("Wolne" = "#A6CEE3", "Zajete" = "#FF7F00")) +
theme_minimal()
print(viz_hour)
# Korelacje między zmiennymi numerycznymi
# Zmienne predykcyjne: Temperature, Humidity, Light, CO2
df_num <- df %>%
select(Temperature, Humidity, Light, CO2, HumidityRatio)
knitr::opts_chunk$set(echo = TRUE)
# instalacja pakietów
#install.packages(c("tidyverse", "caret", "randomForest", "pROC", "corrplot", "rpart.plot"))
# Wczytanie bibliotek
library(tidyverse)
library(lubridate)
library(caret)
library(corrplot)
library(randomForest)
library(rpart)
library(pROC)
library(rpart.plot)
# Wczytanie trzech zestawów danych
df1 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatraining.txt", header = TRUE, sep = ",")
df2 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatest.txt", header = TRUE, sep = ",")
df3 <- read.csv("C:/IiAD/eksploracja_danych/CS/occupancy_data/datatest2.txt", header = TRUE, sep = ",")
# Połączenie danych z wszystkich plików w jeden duży zbiór
# Podział na dane treningowe i testowe zostanie wykonany w dalszej części!
df <- bind_rows(df1, df2, df3)
# Wyświetlenie danych
head(df)
# Sprawdzenie wymiarów danych
dim(df)
# Sprawdzenie struktury danych
str(df)
# Sprawdzenie braków danych
sum(is.na(df))
sum(!complete.cases(df))
# Sprawdzenie podstawowych statystyk dla zmiennych
# Wykrywanie wartości błędnych, ekstremalnych i odstających
summary(df)
# Przekształcenie typów zmiennych, utworzenie nowych zmiennych
df <- df %>%
mutate(date = ymd_hms(date)) %>%  # Przekształcenie zmiennej 'date' na format daty
# Ujednolicenie i zaokrąglanie pomiarów (korygowanie sekundy 59 do następnej minuty)
mutate(date = if_else(second(date) == 59, ceiling_date(date, unit = "minute"), date)) %>%
mutate(
Hour = hour(date),
Minute = minute(date),
Time = paste0(str_pad(Hour, 2, pad = "0"), ":",
str_pad(Minute, 2, pad = "0")) %>% as.factor(), # Czas wykonania pomiaru godzina:minuta
DayOfWeek = wday(date, label = TRUE, abbr = TRUE) # Dzień Tygodnia
)
# Przekształcenie zmiennej docelowej i zmiennych Hour i Time na Factor (Klasyfikacja)
df <- df %>%
mutate(
Occupancy = factor(Occupancy, levels = c(0, 1), labels = c("Wolne", "Zajete")),
Hour = as.factor(Hour),
Time = as.factor(Time))
# Ostateczne selekcje kolumn
df <- df %>%
select(-date, -Minute, -Time)
# Struktura danych po Inżynierii Cech
str(df)
head(df)
# Sprawdzenie rozkładu klas w zmiennej docelowej - Occupancy
table(df$Occupancy)
prop.table(table(df$Occupancy))
# Wizualizacja rozkładu klas
hist_occupancy <- ggplot(df, aes(x = Occupancy, fill = Occupancy)) +
geom_bar() +
labs(title = "Rozkład zmiennej Occupancy", y = "Liczba Obserwacji") +
theme_minimal()
print(hist_occupancy)
# Analiza zmiennych numerycznych: Temperature, Humidity, Light, CO2, HumidityRatio
# Histogramy
hist_all <- df %>%
select(Temperature, Humidity, Light, CO2, HumidityRatio) %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = Value)) +
geom_histogram(bins = 30, fill = "#1F78B4", color = "white") +
facet_wrap(~ Variable, scales = "free") +
labs(title = "Histogramy Rozkładu Głównych Zmiennych Środowiskowych",
x = "Wartość", y = "Liczność") +
theme_minimal()
print(hist_all)
# Boxploty
boxplot_occupancy <- df %>%
select(Occupancy, Temperature, Humidity, Light, CO2, HumidityRatio) %>%
pivot_longer(cols = c(Temperature, Humidity, Light, CO2, HumidityRatio), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = Occupancy, y = Value, fill = Occupancy)) +
geom_boxplot(alpha = 0.8) +
facet_wrap(~ Variable, scales = "free_y", ncol = 4) +
labs(title = "Boxploty Zmiennych Środowiskowych w zależności od Zajętości",
x = "Status Zajętości", y = "Wartość Zmiennej") +
theme_minimal() +
theme(legend.position = "none")
print(boxplot_occupancy)
# Wykres Słupkowy - wizualizacja proporcji zajętości w zależności od dnia tygodnia
barplot_dayofweek <- ggplot(df, aes(x = DayOfWeek, fill = Occupancy)) +
geom_bar(position = "fill") +
labs(title = "Proporcja Zajętości w zależności od Dnia Tygodnia",
y = "Proporcja", x = "Dzień Tygodnia") +
scale_fill_manual(values = c("Wolne" = "#A6CEE3", "Zajete" = "#FF7F00")) +
theme_minimal()
print(barplot_dayofweek)
# Zależność od Godziny
viz_hour <- ggplot(df, aes(x = Hour, fill = Occupancy)) +
geom_bar(position = "fill") +
labs(title = "Proporcja zajętości w zależności od Godziny",
y = "Proporcja", x = "Godzina (0-23)") +
scale_fill_manual(values = c("Wolne" = "#A6CEE3", "Zajete" = "#FF7F00")) +
theme_minimal()
print(viz_hour)
# Korelacje między zmiennymi numerycznymi
# Zmienne predykcyjne: Temperature, Humidity, Light, CO2
df_num <- df %>%
select(Temperature, Humidity, Light, CO2, HumidityRatio)
# Macierz Korelacji
cor_matrix <- cor(df_num)
cor_matrix
# Wizualizacja Macierzy Korelacji
corrplot(cor_matrix, method = "circle", type = "lower", tl.col = "black", tl.srt = 45,
addCoef.col = "black", number.cex = 0.7)
# Usunięcie kolumny HumidityRatio - zbędne informacje
df <- df %>%
select(-HumidityRatio)
# Ustawienie ziarna losowości dla powtarzalności wyników
set.seed(123)
# # Wyodrębnienie 4 obserwacji do ZBIORU TESTOWEGO
# test_index <- createDataPartition(df$Occupancy, p = 4 / nrow(df), list = FALSE)
# # Zbiór testowy - 4 obserwacje (do końcowej predykcji)
# df_test <- df[head(test_index, 4), ]
# # Zbiór pozostały (do podziału 70/30)
# remaining_data <- df[-test_index, ]
# # Wyodrębnienie 10 obserwacji do ZBIORU TESTOWEGO (50/50)
# df_test <- df %>%
#   group_by(Occupancy) %>%
#   sample_n(5, replace = FALSE) %>%   # Losujemy 5 obserwacje z klasy "Wolne" i 5 z klasy "Zajete"
#   ungroup()
# Wyodrębnienie 9 REPREZENTATYWNYCH obserwacji do ZBIORU TESTOWEGO (stosunek klas: 23/77)
# Losujemy 7 Wolne i 2 Zajęte (Prawidłowy podział reprezentatywny dla całego zbioru (23% Zajete / 77% Wolne))
df_test_wolne <- df %>% filter(Occupancy == "Wolne") %>% sample_n(7)
df_test_zajete <- df %>% filter(Occupancy == "Zajete") %>% sample_n(2)
df_test <- bind_rows(df_test_wolne, df_test_zajete) # Zbiór testowy - 9 obserwacje
# Zbiór pozostały (do podziału 70/30)
# Usuwamy z pierwotnego zbioru df wiersze, które trafiły do df_test
remaining_data <- anti_join(df, df_test)
# Podział pozostałej części na ZIÓR TRENINGOWY (70%) i WALIDACYJNY (30%)
train_index <- createDataPartition(remaining_data$Occupancy, p = 0.70, list = FALSE)
# Zbiór treningowy (70% całości)
df_train <- remaining_data[train_index, ]
# Zbiór walidacyjny (30% całości)
df_val <- remaining_data[-train_index, ]
# Sprawdzenie ostatecznych rozmiarów podzbiorów
cat("Zbiór Uczący (df_train): ", nrow(df_train), "obserwacji,", round(nrow(df_train)/nrow(df)*100, 1), "%,\n")
cat("Zbiór Walidacyjny (df_val): ", nrow(df_val), "obserwacji,", round(nrow(df_val)/nrow(df)*100,1), "%,\n")
cat("Zbiór Predykcyjny (df_test): ", nrow(df_test), "obserwacji.\n")
cat("\nReprezentatywność (Proporcje klasy 'Zajete'):\n")
cat(paste("Cały Zbiór: ", round(prop.table(table(df$Occupancy))["Zajete"] * 100, 2), "%\n"))
cat(paste("Treningowy: ", round(prop.table(table(df_train$Occupancy))["Zajete"] * 100, 2), "%\n"))
cat(paste("Walidacyjny: ", round(prop.table(table(df_val$Occupancy))["Zajete"] * 100, 2), "%\n"))
cat(paste("Testowy (9 obs.): ", round(prop.table(table(df_test$Occupancy))["Zajete"] * 100, 2), "%\n"))
#Model Regresji Logistycznej
model_log <- glm(Occupancy ~ .,
data = df_train,
family = binomial)
print("Podsumowanie Modelu Regresji Logistycznej:")
print(summary(model_log))
# Model Regresji Logistycznej
model_log <- glm(Occupancy ~ Temperature + Humidity + Light + CO2,
data = df_train,
family = binomial)
print("Podsumowanie Modelu Regresji Logistycznej (bez zmiennych Hour i DayOfWeek):")
print(summary(model_log))
# Model Regresji Logistycznej z walidacją krzyżową
# ctrl <- trainControl(method = "cv", number = 5, classProbs = TRUE, summaryFunction = twoClassSummary)
#
# set.seed(123)
#
# model_log2 <- train(Occupancy ~ Temperature + Humidity + Light + CO2,
#                  data = df_train,
#                  method = "glm",
#                  family = "binomial",
#                  trControl = ctrl,
#                  metric = "ROC")
#
# print("Podsumowanie Modelu Regresji Logistycznej z walidacją krzyżową:")
# print(summary(model_log2))
# Model Drzewo Decyzyjne C&RT
set.seed(123)
# Uczenie modelu na zbiorze treningowym
cart_model <- rpart(Occupancy ~ .,
data = df_train,
method = "class")
print("Podsumowanie Modelu Drzewo Decyzyjne C&RT:")
print(cart_model)
# # Wizualizacja drzewa
# rpart.plot(cart_model, box.col=c("red", "green"))
# # Predykcja i ocena modelu na zbiorze testowym do walidacji
# cart_pred_final <- predict(cart_model, df_val, type = "class")
# # Macierz pomyłek
# confusionMatrix(cart_pred_final, df_val$Occupancy)
# Przycinanie drzewa, sprawdzenie czy nie zmieniły się wyniki klasyfikacji
plotcp(cart_model)
printcp(cart_model)
opt <- which.min(cart_model$cptable[,'xerror'])
cp <- cart_model$cptable[opt, 'CP']
pruned_cart <- prune(cart_model,cp)
rpart.plot(pruned_cart, box.col=c("red", "green"))
# cart_pred_final2 <- predict(pruned_cart, df_val, type = "class")
# confusionMatrix(cart_pred_final2, df_val$Occupancy)
# # Predykcja i ocena modelu na zbiorze testowym do walidacji
# cart_pred_val <- predict(cart_model, df_val, type = "class")
# cat("\n--- Drzewo Decyzyjne C&RT ---\n")
# confusionMatrix(cart_pred_val, df_val$Occupancy)
#
# # Predykcja i ocena finalna na zbiorze testowym do predykcji
# cart_pred_final <- predict(cart_model, df_test, type = "class")
# cat("\n--- Zbiór Testowy (Finalny) ---\n")
# confusionMatrix(cart_pred_final, df_test$Occupancy)
# cat(sprintf("\n➡️ FINALNE ACCURACY: %.4f\n", mean(cart_pred_final == df_test$Occupancy)))
# # Model Drzewo Decyzyjne C&RT z walidacją krzyżową
# ctrl <- trainControl(method = "cv", number = 5, classProbs = TRUE, summaryFunction = twoClassSummary)
# set.seed(123)
#
# # Uczenie modelu na zbiorze treningowym
# cart_model <- train(Occupancy ~ .,
#                   data = df_train,
#                   method = "rpart",
#                   trControl = ctrl,
#                   metric = "ROC",
#                   tuneLength = 3)
#
# print("Podsumowanie Modelu Drzewo Decyzyjne C&RT z walidacją krzyżową:")
# print(cart_model)
# # Predykcja i ocena modelu na zbiorze testowym do walidacji
# cart_pred_val <- predict(cart_model, df_val, type = "class")
# cat("\n--- Drzewo Decyzyjne C&RT ---\n")
# confusionMatrix(cart_pred_val, df_val$Occupancy)
#
# # Predykcja i ocena finalna na zbiorze testowym do predykcji
# cart_pred_final <- predict(cart_model, df_test, type = "class")
# cat("\n--- Zbiór Testowy (Finalny) ---\n")
# confusionMatrix(cart_pred_final, df_test$Occupancy)
# cat(sprintf("\n➡️ FINALNE ACCURACY: %.4f\n", mean(cart_pred_final == df_test$Occupancy)))
# Model Random Forest
set.seed(123)
# Uczenie modelu na zbiorze treningowym
rf_model <- randomForest(Occupancy ~ .,
data = df_train,
mtry = floor(sqrt(ncol(df_train) - 1)), #pierwiastek z liczby predyktorów
ntree = 500,
importance = TRUE)
print("Podsumowanie Modelu Random Forest:")
print(rf_model)
# Ważność Cech
cat("\nWażność Cech w Modelu Random Forest:\n")
importance_rf <- importance(rf_model, type = 2)
print(importance_rf[order(importance_rf[,1], decreasing = TRUE), ])
# # Predykcja i ocena modelu na zbiorze do walidacji
# rf_pred_val <- predict(rf_model, df_val, type = "class")
# cat("\n--- Random Forest ---\n")
# confusionMatrix(rf_pred_val, df_val$Occupancy)
#
# # Predykcja i ocena finalna na zbiorze testowym do predykcji
# rf_pred_final <- predict(rf_model, df_test, type = "class")
# cat("\n--- Zbiór Testowy (Finalny) ---\n")
# confusionMatrix(rf_pred_final, df_test$Occupancy)
# cat(sprintf("\n➡️ FINALNE ACCURACY: %.4f\n", mean(rf_pred_final == df_test$Occupancy)))
# # Model Random Forest z walidacją krzyżową
# ctrl <- trainControl(method = "cv", number = 5, classProbs = TRUE, summaryFunction = twoClassSummary)
# set.seed(123)
#
# rf_model2 <- train(Occupancy ~ .,
#                    data = df_train,
#                    method = "rf",
#                    trControl = ctrl,
#                    metric = "ROC",
#                    tuneLength = 3)
#
# print("Podsumowanie Modelu Random Forest z walidacją krzyżową:")
# print(rf_model2)
#
# # Ważność Cech
# cat("\nWażność Cech w Modelu Random Forest:\n")
# importance_rf <- importance(rf_model2$finalModel, type = 2)
# print(importance_rf[order(importance_rf[,1], decreasing = TRUE), ])
# # Predykcja i ocena modelu na zbiorze do walidacji
# rf_pred_val <- predict(rf_model2, df_val, type = "class")
# cat("\n--- Random Forest z walidacją krzyżową---\n")
# confusionMatrix(rf_pred_val, df_val$Occupancy)
#
# # Predykcja i ocena finalna na zbiorze testowym do predykcji
# rf_pred_final <- predict(rf_model2, df_test, type = "class")
# cat("\n--- Zbiór Testowy (Finalny) ---\n")
# confusionMatrix(rf_pred_final, df_test$Occupancy)
# cat(sprintf("\n➡️ FINALNE ACCURACY: %.4f\n", mean(rf_pred_final == df_test$Occupancy)))
#_______________________________________________
# Funkcja Oceny
#_______________________________________________
evaluate_model_full <- function(model, test_data) {
# Predykcja KLAS (type = "class" jest natywne dla rpart i randomForest)
preds_class <- predict(model, newdata = test_data, type = "class")
# Predykcja PRAWDOPODOBIEŃSTW (type = "prob") dla AUC-ROC
preds_prob <- predict(model, newdata = test_data, type = "prob")[, "Zajete"]
cm <- confusionMatrix(preds_class, test_data$Occupancy, positive = "Zajete")
auc <- as.numeric(roc(response = test_data$Occupancy, predictor = preds_prob)$auc)
return(list(
Accuracy = cm$overall['Accuracy'],
Sensitivity = cm$byClass['Sensitivity'],
Specificity = cm$byClass['Specificity'],
AUC_ROC = auc,
Kappa = cm$overall['Kappa'],
CM_Object = cm #Zwraca obiekt Macierzy Konfuzji
))
}
#_______________________________________________
# Pełna Ocena na Zbiorze Walidacyjnym (df_val)
#_______________________________________________
# Ocena C&RT (cart_model)
eval_cart_val <- evaluate_model_full(cart_model, df_val)
# Ocena Random Forest (rf_model2)
eval_rf_val <- evaluate_model_full(rf_model, df_val)
# WYŚWIETLANIE MACIERZY KONFUZJI
cat("\n### Macierz Konfuzji: Drzewo Decyzyjne (C&RT) na zbiorze walidacyjnym\n")
print(eval_cart_val$CM_Object)
cat("\n### Macierz Konfuzji: Las Losowy (Random Forest) na zbiorze walidacyjnym\n")
print(eval_rf_val$CM_Object)
# Tabela Porównawcza Walidacyjna
results_val_final <- data.frame(
Model = c("Drzewo Decyzyjne (C&RT)", "Las Losowy (Random Forest)"),
Accuracy = c(eval_cart_val$Accuracy, eval_rf_val$Accuracy),
Sensitivity = c(eval_cart_val$Sensitivity, eval_rf_val$Sensitivity),
Specificity = c(eval_cart_val$Specificity, eval_rf_val$Specificity),
AUC_ROC = c(eval_cart_val$AUC_ROC, eval_rf_val$AUC_ROC),
Kappa = c(eval_cart_val$Kappa, eval_rf_val$Kappa)
)
cat("\n== Tabela Porównania Modeli na Zbiorze Walidacyjnym (PEŁNA OCENA) ==\n")
print(results_val_final)
# #_____________________________________________________________
# # Ocena Końcowa na Zbiorze Testowym (df_test) - TYLKO ACCURACY
# #_____________________________________________________________
#
# # Predykcja C&RT
# cart_preds_class_test <- predict(cart_model, newdata = df_test, type = "class")
# accuracy_cart_test <- mean(cart_preds_class_test == df_test$Occupancy)
#
# # Predykcja Random Forest
# rf_preds_class_test <- predict(rf_model, newdata = df_test, type = "class")
# accuracy_rf_test <- mean(rf_preds_class_test == df_test$Occupancy)
#
# cat(sprintf("\n➡️ Drzewo Decyzyjne (C&RT) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_cart_test))
# cat(sprintf("➡️ Las Losowy (Random Forest) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_rf_test))
# #_____________________________________________________________
# # Ocena Końcowa na Zbiorze Testowym (df_test) - TYLKO ACCURACY
# #_____________________________________________________________
# Predykcja dla 9 Obserwacji
df_test_no_target <- df_test %>% select(-Occupancy)
# Predykcja C&RT
pred_cart_9_prob <- predict(cart_model, newdata = df_test_no_target, type = "prob")[, "Zajete"]
class_cart_9 <- predict(cart_model, newdata = df_test_no_target, type = "class")
accuracy_cart_test <- mean(class_cart_9 == df_test$Occupancy)
# Predykcja Random Forest
pred_rf_9_prob <- predict(rf_model, newdata = df_test_no_target, type = "prob")[, "Zajete"]
class_rf_9 <- predict(rf_model, newdata = df_test_no_target, type = "class")
accuracy_rf_test <- mean(class_rf_9 == df_test$Occupancy)
cat(sprintf("\n➡️ Drzewo Decyzyjne (C&RT) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_cart_test))
cat(sprintf("➡️ Las Losowy (Random Forest) - FINALNA ACCURACY (df_test): %.4f\n", accuracy_rf_test))
# Zestawienie wyników
results_9_obs <- data.frame(
Obserwacja = 1:9,
Prawdziwa_Klasa = df_test$Occupancy,
CART_Predykcja = class_cart_9,
CART_Prawdopodobienstwo = round(pred_cart_9_prob, 9),
RF_Predykcja = class_rf_9,
RF_Prawdopodobienstwo = round(pred_rf_9_prob, 9)
)
cat("Predykcje dla 9 obserwacji na zbiorze testowym:")
print(results_9_obs)
